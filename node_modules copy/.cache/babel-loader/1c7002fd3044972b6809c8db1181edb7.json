{"ast":null,"code":"'use strict';\n\nconst Msg = require('./core/connection/msg').Msg;\n\nconst KillCursor = require('./core/connection/commands').KillCursor;\n\nconst GetMore = require('./core/connection/commands').GetMore;\n\nconst deepCopy = require('./utils').deepCopy;\n/** Commands that we want to redact because of the sensitive nature of their contents */\n\n\nconst SENSITIVE_COMMANDS = new Set(['authenticate', 'saslStart', 'saslContinue', 'getnonce', 'createUser', 'updateUser', 'copydbgetnonce', 'copydbsaslstart', 'copydb']);\nconst HELLO_COMMANDS = new Set(['hello', 'ismaster', 'isMaster']);\nconst LEGACY_FIND_QUERY_MAP = {\n  $query: 'filter',\n  $orderby: 'sort',\n  $hint: 'hint',\n  $comment: 'comment',\n  $maxScan: 'maxScan',\n  $max: 'max',\n  $min: 'min',\n  $returnKey: 'returnKey',\n  $showDiskLoc: 'showRecordId',\n  $maxTimeMS: 'maxTimeMS',\n  $snapshot: 'snapshot'\n};\nconst LEGACY_FIND_OPTIONS_MAP = {\n  numberToSkip: 'skip',\n  numberToReturn: 'batchSize',\n  returnFieldsSelector: 'projection'\n};\nconst OP_QUERY_KEYS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial', 'exhaust'];\n\nconst collectionName = command => command.ns.split('.')[1];\n\nconst shouldRedactCommand = (commandName, cmd) => SENSITIVE_COMMANDS.has(commandName) || HELLO_COMMANDS.has(commandName) && !!cmd.speculativeAuthenticate;\n/**\n * Extract the actual command from the query, possibly upconverting if it's a legacy\n * format\n *\n * @param {Object} command the command\n */\n\n\nconst extractCommand = command => {\n  let extractedCommand;\n\n  if (command instanceof GetMore) {\n    extractedCommand = {\n      getMore: deepCopy(command.cursorId),\n      collection: collectionName(command),\n      batchSize: command.numberToReturn\n    };\n  } else if (command instanceof KillCursor) {\n    extractedCommand = {\n      killCursors: collectionName(command),\n      cursors: deepCopy(command.cursorIds)\n    };\n  } else if (command instanceof Msg) {\n    extractedCommand = deepCopy(command.command);\n  } else if (command.query && command.query.$query) {\n    let result;\n\n    if (command.ns === 'admin.$cmd') {\n      // upconvert legacy command\n      result = Object.assign({}, command.query.$query);\n    } else {\n      // upconvert legacy find command\n      result = {\n        find: collectionName(command)\n      };\n      Object.keys(LEGACY_FIND_QUERY_MAP).forEach(key => {\n        if (typeof command.query[key] !== 'undefined') result[LEGACY_FIND_QUERY_MAP[key]] = deepCopy(command.query[key]);\n      });\n    }\n\n    Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(key => {\n      if (typeof command[key] !== 'undefined') result[LEGACY_FIND_OPTIONS_MAP[key]] = deepCopy(command[key]);\n    });\n    OP_QUERY_KEYS.forEach(key => {\n      if (command[key]) result[key] = command[key];\n    });\n\n    if (typeof command.pre32Limit !== 'undefined') {\n      result.limit = command.pre32Limit;\n    }\n\n    if (command.query.$explain) {\n      extractedCommand = {\n        explain: result\n      };\n    } else {\n      extractedCommand = result;\n    }\n  } else {\n    extractedCommand = deepCopy(command.query || command);\n  }\n\n  const commandName = Object.keys(extractedCommand)[0];\n  return {\n    cmd: extractedCommand,\n    name: commandName,\n    shouldRedact: shouldRedactCommand(commandName, extractedCommand)\n  };\n};\n\nmodule.exports = {\n  extractCommand\n};","map":{"version":3,"sources":["C:/Users/david/Documents/United Plastics/Maintenance/machines/node_modules/mongodb/lib/command_utils.js"],"names":["Msg","require","KillCursor","GetMore","deepCopy","SENSITIVE_COMMANDS","Set","HELLO_COMMANDS","LEGACY_FIND_QUERY_MAP","$query","$orderby","$hint","$comment","$maxScan","$max","$min","$returnKey","$showDiskLoc","$maxTimeMS","$snapshot","LEGACY_FIND_OPTIONS_MAP","numberToSkip","numberToReturn","returnFieldsSelector","OP_QUERY_KEYS","collectionName","command","ns","split","shouldRedactCommand","commandName","cmd","has","speculativeAuthenticate","extractCommand","extractedCommand","getMore","cursorId","collection","batchSize","killCursors","cursors","cursorIds","query","result","Object","assign","find","keys","forEach","key","pre32Limit","limit","$explain","explain","name","shouldRedact","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst Msg = require('./core/connection/msg').Msg;\nconst KillCursor = require('./core/connection/commands').KillCursor;\nconst GetMore = require('./core/connection/commands').GetMore;\nconst deepCopy = require('./utils').deepCopy;\n\n/** Commands that we want to redact because of the sensitive nature of their contents */\nconst SENSITIVE_COMMANDS = new Set([\n  'authenticate',\n  'saslStart',\n  'saslContinue',\n  'getnonce',\n  'createUser',\n  'updateUser',\n  'copydbgetnonce',\n  'copydbsaslstart',\n  'copydb'\n]);\n\nconst HELLO_COMMANDS = new Set(['hello', 'ismaster', 'isMaster']);\n\nconst LEGACY_FIND_QUERY_MAP = {\n  $query: 'filter',\n  $orderby: 'sort',\n  $hint: 'hint',\n  $comment: 'comment',\n  $maxScan: 'maxScan',\n  $max: 'max',\n  $min: 'min',\n  $returnKey: 'returnKey',\n  $showDiskLoc: 'showRecordId',\n  $maxTimeMS: 'maxTimeMS',\n  $snapshot: 'snapshot'\n};\n\nconst LEGACY_FIND_OPTIONS_MAP = {\n  numberToSkip: 'skip',\n  numberToReturn: 'batchSize',\n  returnFieldsSelector: 'projection'\n};\n\nconst OP_QUERY_KEYS = [\n  'tailable',\n  'oplogReplay',\n  'noCursorTimeout',\n  'awaitData',\n  'partial',\n  'exhaust'\n];\n\nconst collectionName = command => command.ns.split('.')[1];\n\nconst shouldRedactCommand = (commandName, cmd) =>\n  SENSITIVE_COMMANDS.has(commandName) ||\n  (HELLO_COMMANDS.has(commandName) && !!cmd.speculativeAuthenticate);\n\n/**\n * Extract the actual command from the query, possibly upconverting if it's a legacy\n * format\n *\n * @param {Object} command the command\n */\nconst extractCommand = command => {\n  let extractedCommand;\n  if (command instanceof GetMore) {\n    extractedCommand = {\n      getMore: deepCopy(command.cursorId),\n      collection: collectionName(command),\n      batchSize: command.numberToReturn\n    };\n  } else if (command instanceof KillCursor) {\n    extractedCommand = {\n      killCursors: collectionName(command),\n      cursors: deepCopy(command.cursorIds)\n    };\n  } else if (command instanceof Msg) {\n    extractedCommand = deepCopy(command.command);\n  } else if (command.query && command.query.$query) {\n    let result;\n    if (command.ns === 'admin.$cmd') {\n      // upconvert legacy command\n      result = Object.assign({}, command.query.$query);\n    } else {\n      // upconvert legacy find command\n      result = { find: collectionName(command) };\n      Object.keys(LEGACY_FIND_QUERY_MAP).forEach(key => {\n        if (typeof command.query[key] !== 'undefined')\n          result[LEGACY_FIND_QUERY_MAP[key]] = deepCopy(command.query[key]);\n      });\n    }\n\n    Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(key => {\n      if (typeof command[key] !== 'undefined')\n        result[LEGACY_FIND_OPTIONS_MAP[key]] = deepCopy(command[key]);\n    });\n\n    OP_QUERY_KEYS.forEach(key => {\n      if (command[key]) result[key] = command[key];\n    });\n\n    if (typeof command.pre32Limit !== 'undefined') {\n      result.limit = command.pre32Limit;\n    }\n\n    if (command.query.$explain) {\n      extractedCommand = { explain: result };\n    } else {\n      extractedCommand = result;\n    }\n  } else {\n    extractedCommand = deepCopy(command.query || command);\n  }\n\n  const commandName = Object.keys(extractedCommand)[0];\n  return {\n    cmd: extractedCommand,\n    name: commandName,\n    shouldRedact: shouldRedactCommand(commandName, extractedCommand)\n  };\n};\n\nmodule.exports = {\n  extractCommand\n};\n"]},"metadata":{},"sourceType":"script"}