{"ast":null,"code":"'use strict';\n\nmodule.exports = function (modules) {\n  const mc = require('bindings')('mongocrypt');\n\n  const common = require('./common');\n\n  const databaseNamespace = common.databaseNamespace;\n  const collectionNamespace = common.collectionNamespace;\n  const promiseOrCallback = common.promiseOrCallback;\n  const StateMachine = modules.stateMachine.StateMachine;\n\n  const cryptoCallbacks = require('./cryptoCallbacks');\n  /**\n   * @typedef {object} KMSProviders\n   * @description Configuration options that are used by specific KMS providers during key generation, encryption, and decryption.\n   * @property {object} [aws] Configuration options for using 'aws' as your KMS provider\n   * @property {string} [aws.accessKeyId] The access key used for the AWS KMS provider\n   * @property {string} [aws.secretAccessKey] The secret access key used for the AWS KMS provider\n   * @property {object} [local] Configuration options for using 'local' as your KMS provider\n   * @property {Buffer} [local.key] The master key used to encrypt/decrypt data keys. A 96-byte long Buffer.\n   * @property {object} [azure] Configuration options for using 'azure' as your KMS provider\n   * @property {string} [azure.tenantId] The tenant ID identifies the organization for the account\n   * @property {string} [azure.clientId] The client ID to authenticate a registered application\n   * @property {string} [azure.clientSecret] The client secret to authenticate a registered application\n   * @property {string} [azure.identityPlatformEndpoint] If present, a host with optional port. E.g. \"example.com\" or \"example.com:443\". This is optional, and only needed if customer is using a non-commercial Azure instance (e.g. a government or China account, which use different URLs). Defaults to  \"login.microsoftonline.com\"\n   * @property {object} [gcp] Configuration options for using 'gcp' as your KMS provider\n   * @property {string} [gcp.email] The service account email to authenticate\n   * @property {string|Binary} [gcp.privateKey] A PKCS#8 encrypted key. This can either be a base64 string or a binary representation\n   * @property {string} [gcp.endpoint] If present, a host with optional port. E.g. \"example.com\" or \"example.com:443\". Defaults to \"oauth2.googleapis.com\"\n   */\n\n  /**\n   * The public interface for explicit client side encryption\n   */\n\n\n  class ClientEncryption {\n    /**\n     * Create a new encryption instance\n     *\n     * @param {MongoClient} client The client used for encryption\n     * @param {object} options Additional settings\n     * @param {string} options.keyVaultNamespace The namespace of the key vault, used to store encryption keys\n     * @param {MongoClient} [options.keyVaultClient] A `MongoClient` used to fetch keys from a key vault. Defaults to `client`\n     * @param {KMSProviders} [options.kmsProviders] options for specific KMS providers to use\n     *\n     * @example\n     * new ClientEncryption(mongoClient, {\n     *   keyVaultNamespace: 'client.encryption',\n     *   kmsProviders: {\n     *     local: {\n     *       key: masterKey // The master key used for encryption/decryption. A 96-byte long Buffer\n     *     }\n     *   }\n     * });\n     *\n     * @example\n     * new ClientEncryption(mongoClient, {\n     *   keyVaultNamespace: 'client.encryption',\n     *   kmsProviders: {\n     *     aws: {\n     *       accessKeyId: AWS_ACCESS_KEY,\n     *       secretAccessKey: AWS_SECRET_KEY\n     *     }\n     *   }\n     * });\n     */\n    constructor(client, options) {\n      this._client = client;\n      this._bson = options.bson || client.topology.bson;\n\n      if (options.keyVaultNamespace == null) {\n        throw new TypeError('Missing required option `keyVaultNamespace`');\n      }\n\n      Object.assign(options, {\n        cryptoCallbacks\n      }); // kmsProviders will be parsed by libmongocrypt, must be provided as BSON binary data\n\n      if (options.kmsProviders && !Buffer.isBuffer(options.kmsProviders)) {\n        options.kmsProviders = this._bson.serialize(options.kmsProviders);\n      }\n\n      this._keyVaultNamespace = options.keyVaultNamespace;\n      this._keyVaultClient = options.keyVaultClient || client;\n      this._mongoCrypt = new mc.MongoCrypt(options);\n    }\n    /**\n     * @typedef {Binary} ClientEncryption~dataKeyId\n     * @description The id of an existing dataKey. Is a bson Binary value.\n     * Can be used for {@link ClientEncryption.encrypt}, and can be used to directly\n     * query for the data key itself against the key vault namespace.\n     */\n\n    /**\n     * @callback ClientEncryption~createDataKeyCallback\n     * @param {Error} [error] If present, indicates an error that occurred in the creation of the data key\n     * @param {ClientEncryption~dataKeyId} [dataKeyId] If present, returns the id of the created data key\n     */\n\n    /**\n     * @typedef {object} AWSEncryptionKeyOptions\n     * @description Configuration options for making an AWS encryption key\n     * @property {string} region The AWS region of the KMS\n     * @property {string} key The Amazon Resource Name (ARN) to the AWS customer master key (CMK)\n     * @property {string} [endpoint] An alternate host to send KMS requests to. May include port number\n     */\n\n    /**\n     * @typedef {object} GCPEncryptionKeyOptions\n     * @description Configuration options for making a GCP encryption key\n     * @property {string} projectId GCP project id\n     * @property {string} location Location name (e.g. \"global\")\n     * @property {string} keyRing Key ring name\n     * @property {string} keyName Key name\n     * @property {string} [keyVersion] Key version\n     * @property {string} [endpoint] KMS URL, defaults to `https://www.googleapis.com/auth/cloudkms`\n     */\n\n    /**\n     * @typedef {object} AzureEncryptionKeyOptions\n     * @description Configuration options for making an Azure encryption key\n     * @property {string} keyName Key name\n     * @property {string} keyVaultEndpoint Key vault URL, typically `<name>.vault.azure.net`\n     * @property {string} [keyVersion] Key version\n     */\n\n    /**\n     * Creates a data key used for explicit encryption and inserts it into the key vault namespace\n     *\n     * @param {string} provider The KMS provider used for this data key. Must be `'aws'`, `'azure'`, `'gcp'`, or `'local'`\n     * @param {object} [options] Options for creating the data key\n     * @param {AWSEncryptionKeyOptions|AzureEncryptionKeyOptions|GCPEncryptionKeyOptions} [options.masterKey] Idenfities a new KMS-specific key used to encrypt the new data key\n     * @param {string[]} [options.keyAltNames] An optional list of string alternate names used to reference a key. If a key is created with alternate names, then encryption may refer to the key by the unique alternate name instead of by _id.\n     * @param {ClientEncryption~createDataKeyCallback} [callback] Optional callback to invoke when key is created\n     * @returns {Promise|void} If no callback is provided, returns a Promise that either resolves with {@link ClientEncryption~dataKeyId the id of the created data key}, or rejects with an error. If a callback is provided, returns nothing.\n     * @example\n     * // Using callbacks to create a local key\n     * clientEncryption.createDataKey('local', (err, dataKey) => {\n     *   if (err) {\n     *     // This means creating the key failed.\n     *   } else {\n     *     // key creation succeeded\n     *   }\n     * });\n     *\n     * @example\n     * // Using async/await to create a local key\n     * const dataKeyId = await clientEncryption.createDataKey('local');\n     *\n     * @example\n     * // Using async/await to create an aws key\n     * const dataKeyId = await clientEncryption.createDataKey('aws', {\n     *   masterKey: {\n     *     region: 'us-east-1',\n     *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\n     *   }\n     * });\n     *\n     * @example\n     * // Using async/await to create an aws key with a keyAltName\n     * const dataKeyId = await clientEncryption.createDataKey('aws', {\n     *   masterKey: {\n     *     region: 'us-east-1',\n     *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\n     *   },\n     *   keyAltNames: [ 'mySpecialKey' ]\n     * });\n     */\n\n\n    createDataKey(provider, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      if (typeof options === 'undefined') {\n        options = {};\n      }\n\n      const bson = this._bson;\n      const dataKey = Object.assign({\n        provider\n      }, options.masterKey);\n\n      if (options.keyAltNames && !Array.isArray(options.keyAltNames)) {\n        throw new TypeError(`Option \"keyAltNames\" must be an array of strings, but was of type ${typeof options.keyAltNames}.`);\n      }\n\n      let keyAltNames = undefined;\n\n      if (options.keyAltNames && options.keyAltNames.length > 0) {\n        keyAltNames = options.keyAltNames.map((keyAltName, i) => {\n          if (typeof keyAltName !== 'string') {\n            throw new TypeError(`Option \"keyAltNames\" must be an array of strings, but item at index ${i} was of type ${typeof keyAltName}`);\n          }\n\n          return bson.serialize({\n            keyAltName\n          });\n        });\n      }\n\n      const dataKeyBson = bson.serialize(dataKey);\n\n      const context = this._mongoCrypt.makeDataKeyContext(dataKeyBson, {\n        keyAltNames\n      });\n\n      const stateMachine = new StateMachine({\n        bson\n      });\n      return promiseOrCallback(callback, cb => {\n        stateMachine.execute(this, context, (err, dataKey) => {\n          if (err) {\n            cb(err, null);\n            return;\n          }\n\n          const dbName = databaseNamespace(this._keyVaultNamespace);\n          const collectionName = collectionNamespace(this._keyVaultNamespace);\n\n          this._keyVaultClient.db(dbName).collection(collectionName).insertOne(dataKey, {\n            writeConcern: {\n              w: 'majority'\n            }\n          }, (err, result) => {\n            if (err) {\n              cb(err, null);\n              return;\n            }\n\n            cb(null, result.insertedId);\n          });\n        });\n      });\n    }\n    /**\n     * @callback ClientEncryption~encryptCallback\n     * @param {Error} [err] If present, indicates an error that occurred in the process of encryption\n     * @param {Buffer} [result] If present, is the encrypted result\n     */\n\n    /**\n     * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must\n     * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.\n     *\n     * @param {*} value The value that you wish to serialize. Must be of a type that can be serialized into BSON\n     * @param {object} options\n     * @param {ClientEncryption~dataKeyId} [options.keyId] The id of the Binary dataKey to use for encryption\n     * @param {string} [options.keyAltName] A unique string name corresponding to an already existing dataKey.\n     * @param {} options.algorithm The algorithm to use for encryption. Must be either `'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic'` or `AEAD_AES_256_CBC_HMAC_SHA_512-Random'`\n     * @param {ClientEncryption~encryptCallback} [callback] Optional callback to invoke when value is encrypted\n     * @returns {Promise|void} If no callback is provided, returns a Promise that either resolves with the encrypted value, or rejects with an error. If a callback is provided, returns nothing.\n     *\n     * @example\n     * // Encryption with callback API\n     * function encryptMyData(value, callback) {\n     *   clientEncryption.createDataKey('local', (err, keyId) => {\n     *     if (err) {\n     *       return callback(err);\n     *     }\n     *     clientEncryption.encrypt(value, { keyId, algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' }, callback);\n     *   });\n     * }\n     *\n     * @example\n     * // Encryption with async/await api\n     * async function encryptMyData(value) {\n     *   const keyId = await clientEncryption.createDataKey('local');\n     *   return clientEncryption.encrypt(value, { keyId, algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\n     * }\n     *\n     * @example\n     * // Encryption using a keyAltName\n     * async function encryptMyData(value) {\n     *   await clientEncryption.createDataKey('local', { keyAltNames: 'mySpecialKey' });\n     *   return clientEncryption.encrypt(value, { keyAltName: 'mySpecialKey', algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\n     * }\n     */\n\n\n    encrypt(value, options, callback) {\n      const bson = this._bson;\n      const valueBuffer = bson.serialize({\n        v: value\n      });\n      const contextOptions = Object.assign({}, options);\n\n      if (options.keyId) {\n        contextOptions.keyId = options.keyId.buffer;\n      }\n\n      if (options.keyAltName) {\n        const keyAltName = options.keyAltName;\n\n        if (options.keyId) {\n          throw new TypeError(`\"options\" cannot contain both \"keyId\" and \"keyAltName\"`);\n        }\n\n        const keyAltNameType = typeof keyAltName;\n\n        if (keyAltNameType !== 'string') {\n          throw new TypeError(`\"options.keyAltName\" must be of type string, but was of type ${keyAltNameType}`);\n        }\n\n        contextOptions.keyAltName = bson.serialize({\n          keyAltName\n        });\n      }\n\n      const stateMachine = new StateMachine({\n        bson\n      });\n\n      const context = this._mongoCrypt.makeExplicitEncryptionContext(valueBuffer, contextOptions);\n\n      return promiseOrCallback(callback, cb => {\n        stateMachine.execute(this, context, (err, result) => {\n          if (err) {\n            cb(err, null);\n            return;\n          }\n\n          cb(null, result.v);\n        });\n      });\n    }\n    /**\n     * @callback ClientEncryption~decryptCallback\n     * @param {Error} [err] If present, indicates an error that occurred in the process of decryption\n     * @param {object} [result] If present, is the decrypted result\n     */\n\n    /**\n     * Explicitly decrypt a provided encrypted value\n     *\n     * @param {Buffer} value An encrypted value\n     * @param {ClientEncryption~decryptCallback} callback Optional callback to invoke when value is decrypted\n     * @returns {Promise|void} If no callback is provided, returns a Promise that either resolves with the decryped value, or rejects with an error. If a callback is provided, returns nothing.\n     *\n     * @example\n     * // Decrypting value with callback API\n     * function decryptMyValue(value, callback) {\n     *   clientEncryption.decrypt(value, callback);\n     * }\n     *\n     * @example\n     * // Decrypting value with async/await API\n     * async function decryptMyValue(value) {\n     *   return clientEncryption.decrypt(value);\n     * }\n     */\n\n\n    decrypt(value, callback) {\n      const bson = this._bson;\n      const valueBuffer = bson.serialize({\n        v: value\n      });\n\n      const context = this._mongoCrypt.makeExplicitDecryptionContext(valueBuffer);\n\n      const stateMachine = new StateMachine({\n        bson\n      });\n      return promiseOrCallback(callback, cb => {\n        stateMachine.execute(this, context, (err, result) => {\n          if (err) {\n            cb(err, null);\n            return;\n          }\n\n          cb(null, result.v);\n        });\n      });\n    }\n\n  }\n\n  return {\n    ClientEncryption\n  };\n};","map":{"version":3,"sources":["C:/Users/david/Documents/United Plastics/Maintenance/machines/node_modules/mongodb-client-encryption/lib/clientEncryption.js"],"names":["module","exports","modules","mc","require","common","databaseNamespace","collectionNamespace","promiseOrCallback","StateMachine","stateMachine","cryptoCallbacks","ClientEncryption","constructor","client","options","_client","_bson","bson","topology","keyVaultNamespace","TypeError","Object","assign","kmsProviders","Buffer","isBuffer","serialize","_keyVaultNamespace","_keyVaultClient","keyVaultClient","_mongoCrypt","MongoCrypt","createDataKey","provider","callback","dataKey","masterKey","keyAltNames","Array","isArray","undefined","length","map","keyAltName","i","dataKeyBson","context","makeDataKeyContext","cb","execute","err","dbName","collectionName","db","collection","insertOne","writeConcern","w","result","insertedId","encrypt","value","valueBuffer","v","contextOptions","keyId","buffer","keyAltNameType","makeExplicitEncryptionContext","decrypt","makeExplicitDecryptionContext"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = function(modules) {\n  const mc = require('bindings')('mongocrypt');\n  const common = require('./common');\n  const databaseNamespace = common.databaseNamespace;\n  const collectionNamespace = common.collectionNamespace;\n  const promiseOrCallback = common.promiseOrCallback;\n  const StateMachine = modules.stateMachine.StateMachine;\n  const cryptoCallbacks = require('./cryptoCallbacks');\n\n  /**\n   * @typedef {object} KMSProviders\n   * @description Configuration options that are used by specific KMS providers during key generation, encryption, and decryption.\n   * @property {object} [aws] Configuration options for using 'aws' as your KMS provider\n   * @property {string} [aws.accessKeyId] The access key used for the AWS KMS provider\n   * @property {string} [aws.secretAccessKey] The secret access key used for the AWS KMS provider\n   * @property {object} [local] Configuration options for using 'local' as your KMS provider\n   * @property {Buffer} [local.key] The master key used to encrypt/decrypt data keys. A 96-byte long Buffer.\n   * @property {object} [azure] Configuration options for using 'azure' as your KMS provider\n   * @property {string} [azure.tenantId] The tenant ID identifies the organization for the account\n   * @property {string} [azure.clientId] The client ID to authenticate a registered application\n   * @property {string} [azure.clientSecret] The client secret to authenticate a registered application\n   * @property {string} [azure.identityPlatformEndpoint] If present, a host with optional port. E.g. \"example.com\" or \"example.com:443\". This is optional, and only needed if customer is using a non-commercial Azure instance (e.g. a government or China account, which use different URLs). Defaults to  \"login.microsoftonline.com\"\n   * @property {object} [gcp] Configuration options for using 'gcp' as your KMS provider\n   * @property {string} [gcp.email] The service account email to authenticate\n   * @property {string|Binary} [gcp.privateKey] A PKCS#8 encrypted key. This can either be a base64 string or a binary representation\n   * @property {string} [gcp.endpoint] If present, a host with optional port. E.g. \"example.com\" or \"example.com:443\". Defaults to \"oauth2.googleapis.com\"\n   */\n\n  /**\n   * The public interface for explicit client side encryption\n   */\n  class ClientEncryption {\n    /**\n     * Create a new encryption instance\n     *\n     * @param {MongoClient} client The client used for encryption\n     * @param {object} options Additional settings\n     * @param {string} options.keyVaultNamespace The namespace of the key vault, used to store encryption keys\n     * @param {MongoClient} [options.keyVaultClient] A `MongoClient` used to fetch keys from a key vault. Defaults to `client`\n     * @param {KMSProviders} [options.kmsProviders] options for specific KMS providers to use\n     *\n     * @example\n     * new ClientEncryption(mongoClient, {\n     *   keyVaultNamespace: 'client.encryption',\n     *   kmsProviders: {\n     *     local: {\n     *       key: masterKey // The master key used for encryption/decryption. A 96-byte long Buffer\n     *     }\n     *   }\n     * });\n     *\n     * @example\n     * new ClientEncryption(mongoClient, {\n     *   keyVaultNamespace: 'client.encryption',\n     *   kmsProviders: {\n     *     aws: {\n     *       accessKeyId: AWS_ACCESS_KEY,\n     *       secretAccessKey: AWS_SECRET_KEY\n     *     }\n     *   }\n     * });\n     */\n    constructor(client, options) {\n      this._client = client;\n      this._bson = options.bson || client.topology.bson;\n\n      if (options.keyVaultNamespace == null) {\n        throw new TypeError('Missing required option `keyVaultNamespace`');\n      }\n\n      Object.assign(options, { cryptoCallbacks });\n\n      // kmsProviders will be parsed by libmongocrypt, must be provided as BSON binary data\n      if (options.kmsProviders && !Buffer.isBuffer(options.kmsProviders)) {\n        options.kmsProviders = this._bson.serialize(options.kmsProviders);\n      }\n\n      this._keyVaultNamespace = options.keyVaultNamespace;\n      this._keyVaultClient = options.keyVaultClient || client;\n      this._mongoCrypt = new mc.MongoCrypt(options);\n    }\n\n    /**\n     * @typedef {Binary} ClientEncryption~dataKeyId\n     * @description The id of an existing dataKey. Is a bson Binary value.\n     * Can be used for {@link ClientEncryption.encrypt}, and can be used to directly\n     * query for the data key itself against the key vault namespace.\n     */\n\n    /**\n     * @callback ClientEncryption~createDataKeyCallback\n     * @param {Error} [error] If present, indicates an error that occurred in the creation of the data key\n     * @param {ClientEncryption~dataKeyId} [dataKeyId] If present, returns the id of the created data key\n     */\n\n    /**\n     * @typedef {object} AWSEncryptionKeyOptions\n     * @description Configuration options for making an AWS encryption key\n     * @property {string} region The AWS region of the KMS\n     * @property {string} key The Amazon Resource Name (ARN) to the AWS customer master key (CMK)\n     * @property {string} [endpoint] An alternate host to send KMS requests to. May include port number\n     */\n\n    /**\n     * @typedef {object} GCPEncryptionKeyOptions\n     * @description Configuration options for making a GCP encryption key\n     * @property {string} projectId GCP project id\n     * @property {string} location Location name (e.g. \"global\")\n     * @property {string} keyRing Key ring name\n     * @property {string} keyName Key name\n     * @property {string} [keyVersion] Key version\n     * @property {string} [endpoint] KMS URL, defaults to `https://www.googleapis.com/auth/cloudkms`\n     */\n\n    /**\n     * @typedef {object} AzureEncryptionKeyOptions\n     * @description Configuration options for making an Azure encryption key\n     * @property {string} keyName Key name\n     * @property {string} keyVaultEndpoint Key vault URL, typically `<name>.vault.azure.net`\n     * @property {string} [keyVersion] Key version\n     */\n\n    /**\n     * Creates a data key used for explicit encryption and inserts it into the key vault namespace\n     *\n     * @param {string} provider The KMS provider used for this data key. Must be `'aws'`, `'azure'`, `'gcp'`, or `'local'`\n     * @param {object} [options] Options for creating the data key\n     * @param {AWSEncryptionKeyOptions|AzureEncryptionKeyOptions|GCPEncryptionKeyOptions} [options.masterKey] Idenfities a new KMS-specific key used to encrypt the new data key\n     * @param {string[]} [options.keyAltNames] An optional list of string alternate names used to reference a key. If a key is created with alternate names, then encryption may refer to the key by the unique alternate name instead of by _id.\n     * @param {ClientEncryption~createDataKeyCallback} [callback] Optional callback to invoke when key is created\n     * @returns {Promise|void} If no callback is provided, returns a Promise that either resolves with {@link ClientEncryption~dataKeyId the id of the created data key}, or rejects with an error. If a callback is provided, returns nothing.\n     * @example\n     * // Using callbacks to create a local key\n     * clientEncryption.createDataKey('local', (err, dataKey) => {\n     *   if (err) {\n     *     // This means creating the key failed.\n     *   } else {\n     *     // key creation succeeded\n     *   }\n     * });\n     *\n     * @example\n     * // Using async/await to create a local key\n     * const dataKeyId = await clientEncryption.createDataKey('local');\n     *\n     * @example\n     * // Using async/await to create an aws key\n     * const dataKeyId = await clientEncryption.createDataKey('aws', {\n     *   masterKey: {\n     *     region: 'us-east-1',\n     *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\n     *   }\n     * });\n     *\n     * @example\n     * // Using async/await to create an aws key with a keyAltName\n     * const dataKeyId = await clientEncryption.createDataKey('aws', {\n     *   masterKey: {\n     *     region: 'us-east-1',\n     *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\n     *   },\n     *   keyAltNames: [ 'mySpecialKey' ]\n     * });\n     */\n    createDataKey(provider, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n      if (typeof options === 'undefined') {\n        options = {};\n      }\n\n      const bson = this._bson;\n\n      const dataKey = Object.assign({ provider }, options.masterKey);\n\n      if (options.keyAltNames && !Array.isArray(options.keyAltNames)) {\n        throw new TypeError(\n          `Option \"keyAltNames\" must be an array of strings, but was of type ${typeof options.keyAltNames}.`\n        );\n      }\n\n      let keyAltNames = undefined;\n      if (options.keyAltNames && options.keyAltNames.length > 0) {\n        keyAltNames = options.keyAltNames.map((keyAltName, i) => {\n          if (typeof keyAltName !== 'string') {\n            throw new TypeError(\n              `Option \"keyAltNames\" must be an array of strings, but item at index ${i} was of type ${typeof keyAltName}`\n            );\n          }\n\n          return bson.serialize({ keyAltName });\n        });\n      }\n\n      const dataKeyBson = bson.serialize(dataKey);\n      const context = this._mongoCrypt.makeDataKeyContext(dataKeyBson, { keyAltNames });\n      const stateMachine = new StateMachine({ bson });\n\n      return promiseOrCallback(callback, cb => {\n        stateMachine.execute(this, context, (err, dataKey) => {\n          if (err) {\n            cb(err, null);\n            return;\n          }\n\n          const dbName = databaseNamespace(this._keyVaultNamespace);\n          const collectionName = collectionNamespace(this._keyVaultNamespace);\n\n          this._keyVaultClient\n            .db(dbName)\n            .collection(collectionName)\n            .insertOne(dataKey, { writeConcern: { w: 'majority' } }, (err, result) => {\n              if (err) {\n                cb(err, null);\n                return;\n              }\n\n              cb(null, result.insertedId);\n            });\n        });\n      });\n    }\n\n    /**\n     * @callback ClientEncryption~encryptCallback\n     * @param {Error} [err] If present, indicates an error that occurred in the process of encryption\n     * @param {Buffer} [result] If present, is the encrypted result\n     */\n\n    /**\n     * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must\n     * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.\n     *\n     * @param {*} value The value that you wish to serialize. Must be of a type that can be serialized into BSON\n     * @param {object} options\n     * @param {ClientEncryption~dataKeyId} [options.keyId] The id of the Binary dataKey to use for encryption\n     * @param {string} [options.keyAltName] A unique string name corresponding to an already existing dataKey.\n     * @param {} options.algorithm The algorithm to use for encryption. Must be either `'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic'` or `AEAD_AES_256_CBC_HMAC_SHA_512-Random'`\n     * @param {ClientEncryption~encryptCallback} [callback] Optional callback to invoke when value is encrypted\n     * @returns {Promise|void} If no callback is provided, returns a Promise that either resolves with the encrypted value, or rejects with an error. If a callback is provided, returns nothing.\n     *\n     * @example\n     * // Encryption with callback API\n     * function encryptMyData(value, callback) {\n     *   clientEncryption.createDataKey('local', (err, keyId) => {\n     *     if (err) {\n     *       return callback(err);\n     *     }\n     *     clientEncryption.encrypt(value, { keyId, algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' }, callback);\n     *   });\n     * }\n     *\n     * @example\n     * // Encryption with async/await api\n     * async function encryptMyData(value) {\n     *   const keyId = await clientEncryption.createDataKey('local');\n     *   return clientEncryption.encrypt(value, { keyId, algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\n     * }\n     *\n     * @example\n     * // Encryption using a keyAltName\n     * async function encryptMyData(value) {\n     *   await clientEncryption.createDataKey('local', { keyAltNames: 'mySpecialKey' });\n     *   return clientEncryption.encrypt(value, { keyAltName: 'mySpecialKey', algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\n     * }\n     */\n    encrypt(value, options, callback) {\n      const bson = this._bson;\n      const valueBuffer = bson.serialize({ v: value });\n      const contextOptions = Object.assign({}, options);\n      if (options.keyId) {\n        contextOptions.keyId = options.keyId.buffer;\n      }\n      if (options.keyAltName) {\n        const keyAltName = options.keyAltName;\n        if (options.keyId) {\n          throw new TypeError(`\"options\" cannot contain both \"keyId\" and \"keyAltName\"`);\n        }\n        const keyAltNameType = typeof keyAltName;\n        if (keyAltNameType !== 'string') {\n          throw new TypeError(\n            `\"options.keyAltName\" must be of type string, but was of type ${keyAltNameType}`\n          );\n        }\n\n        contextOptions.keyAltName = bson.serialize({ keyAltName });\n      }\n\n      const stateMachine = new StateMachine({ bson });\n      const context = this._mongoCrypt.makeExplicitEncryptionContext(valueBuffer, contextOptions);\n\n      return promiseOrCallback(callback, cb => {\n        stateMachine.execute(this, context, (err, result) => {\n          if (err) {\n            cb(err, null);\n            return;\n          }\n\n          cb(null, result.v);\n        });\n      });\n    }\n\n    /**\n     * @callback ClientEncryption~decryptCallback\n     * @param {Error} [err] If present, indicates an error that occurred in the process of decryption\n     * @param {object} [result] If present, is the decrypted result\n     */\n\n    /**\n     * Explicitly decrypt a provided encrypted value\n     *\n     * @param {Buffer} value An encrypted value\n     * @param {ClientEncryption~decryptCallback} callback Optional callback to invoke when value is decrypted\n     * @returns {Promise|void} If no callback is provided, returns a Promise that either resolves with the decryped value, or rejects with an error. If a callback is provided, returns nothing.\n     *\n     * @example\n     * // Decrypting value with callback API\n     * function decryptMyValue(value, callback) {\n     *   clientEncryption.decrypt(value, callback);\n     * }\n     *\n     * @example\n     * // Decrypting value with async/await API\n     * async function decryptMyValue(value) {\n     *   return clientEncryption.decrypt(value);\n     * }\n     */\n    decrypt(value, callback) {\n      const bson = this._bson;\n      const valueBuffer = bson.serialize({ v: value });\n      const context = this._mongoCrypt.makeExplicitDecryptionContext(valueBuffer);\n\n      const stateMachine = new StateMachine({ bson });\n\n      return promiseOrCallback(callback, cb => {\n        stateMachine.execute(this, context, (err, result) => {\n          if (err) {\n            cb(err, null);\n            return;\n          }\n\n          cb(null, result.v);\n        });\n      });\n    }\n  }\n\n  return { ClientEncryption };\n};\n"]},"metadata":{},"sourceType":"script"}