{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst ConnectionPool = require('../../cmap/connection_pool').ConnectionPool;\n\nconst CMAP_EVENT_NAMES = require('../../cmap/events').CMAP_EVENT_NAMES;\n\nconst MongoError = require('../error').MongoError;\n\nconst relayEvents = require('../utils').relayEvents;\n\nconst BSON = require('../connection/utils').retrieveBSON();\n\nconst Logger = require('../connection/logger');\n\nconst ServerDescription = require('./server_description').ServerDescription;\n\nconst compareTopologyVersion = require('./server_description').compareTopologyVersion;\n\nconst ReadPreference = require('../topologies/read_preference');\n\nconst Monitor = require('./monitor').Monitor;\n\nconst MongoNetworkError = require('../error').MongoNetworkError;\n\nconst MongoNetworkTimeoutError = require('../error').MongoNetworkTimeoutError;\n\nconst collationNotSupported = require('../utils').collationNotSupported;\n\nconst debugOptions = require('../connection/utils').debugOptions;\n\nconst isSDAMUnrecoverableError = require('../error').isSDAMUnrecoverableError;\n\nconst isRetryableWriteError = require('../error').isRetryableWriteError;\n\nconst isNodeShuttingDownError = require('../error').isNodeShuttingDownError;\n\nconst isNetworkErrorBeforeHandshake = require('../error').isNetworkErrorBeforeHandshake;\n\nconst maxWireVersion = require('../utils').maxWireVersion;\n\nconst makeStateMachine = require('../utils').makeStateMachine;\n\nconst extractCommand = require('../../command_utils').extractCommand;\n\nconst common = require('./common');\n\nconst ServerType = common.ServerType;\n\nconst isTransactionCommand = require('../transactions').isTransactionCommand; // Used for filtering out fields for logging\n\n\nconst DEBUG_FIELDS = ['reconnect', 'reconnectTries', 'reconnectInterval', 'emitError', 'cursorFactory', 'host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'checkServerIdentity', 'socketTimeout', 'ssl', 'ca', 'crl', 'cert', 'key', 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bsonRegExp', 'servername'];\nconst STATE_CLOSING = common.STATE_CLOSING;\nconst STATE_CLOSED = common.STATE_CLOSED;\nconst STATE_CONNECTING = common.STATE_CONNECTING;\nconst STATE_CONNECTED = common.STATE_CONNECTED;\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],\n  [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],\n  [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]\n});\nconst kMonitor = Symbol('monitor');\n/**\n *\n * @fires Server#serverHeartbeatStarted\n * @fires Server#serverHeartbeatSucceeded\n * @fires Server#serverHeartbeatFailed\n */\n\nclass Server extends EventEmitter {\n  /**\n   * Create a server\n   *\n   * @param {ServerDescription} description\n   * @param {Object} options\n   */\n  constructor(description, options, topology) {\n    super();\n    this.s = {\n      // the server description\n      description,\n      // a saved copy of the incoming options\n      options,\n      // the server logger\n      logger: Logger('Server', options),\n      // the bson parser\n      bson: options.bson || new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128, BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey, BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]),\n      // the server state\n      state: STATE_CLOSED,\n      credentials: options.credentials,\n      topology\n    }; // create the connection pool\n    // NOTE: this used to happen in `connect`, we supported overriding pool options there\n\n    const poolOptions = Object.assign({\n      host: this.description.host,\n      port: this.description.port,\n      bson: this.s.bson\n    }, options);\n    this.s.pool = new ConnectionPool(poolOptions);\n    relayEvents(this.s.pool, this, ['commandStarted', 'commandSucceeded', 'commandFailed'].concat(CMAP_EVENT_NAMES));\n    this.s.pool.on('clusterTimeReceived', clusterTime => {\n      this.clusterTime = clusterTime;\n    }); // create the monitor\n\n    this[kMonitor] = new Monitor(this, this.s.options);\n    relayEvents(this[kMonitor], this, ['serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', // legacy events\n    'monitoring']);\n    this[kMonitor].on('resetConnectionPool', () => {\n      this.s.pool.clear();\n    });\n    this[kMonitor].on('resetServer', error => markServerUnknown(this, error));\n    this[kMonitor].on('serverHeartbeatSucceeded', event => {\n      this.emit('descriptionReceived', new ServerDescription(this.description.address, event.reply, {\n        roundTripTime: calculateRoundTripTime(this.description.roundTripTime, event.duration)\n      }));\n\n      if (this.s.state === STATE_CONNECTING) {\n        stateTransition(this, STATE_CONNECTED);\n        this.emit('connect', this);\n      }\n    });\n  }\n\n  get description() {\n    return this.s.description;\n  }\n\n  get supportsRetryableWrites() {\n    return supportsRetryableWrites(this);\n  }\n\n  get name() {\n    return this.s.description.address;\n  }\n\n  get autoEncrypter() {\n    if (this.s.options && this.s.options.autoEncrypter) {\n      return this.s.options.autoEncrypter;\n    }\n\n    return null;\n  }\n  /**\n   * Initiate server connect\n   */\n\n\n  connect() {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    }\n\n    stateTransition(this, STATE_CONNECTING);\n    this[kMonitor].connect();\n  }\n  /**\n   * Destroy the server connection\n   *\n   * @param {object} [options] Optional settings\n   * @param {Boolean} [options.force=false] Force destroy the pool\n   */\n\n\n  destroy(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = Object.assign({}, {\n      force: false\n    }, options);\n\n    if (this.s.state === STATE_CLOSED) {\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    this[kMonitor].close();\n    this.s.pool.close(options, err => {\n      stateTransition(this, STATE_CLOSED);\n      this.emit('closed');\n\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n    });\n  }\n  /**\n   * Immediately schedule monitoring of this server. If there already an attempt being made\n   * this will be a no-op.\n   */\n\n\n  requestCheck() {\n    this[kMonitor].requestCheck();\n  }\n  /**\n   * Execute a command\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cmd The command hash\n   * @param {object} [options] Optional settings\n   * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.checkKeys=false] Specify if the bson parser should validate keys.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {Boolean} [options.fullResult=false] Return the full envelope instead of just the result document.\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n\n\n  command(ns, cmd, options, callback) {\n    if (typeof options === 'function') {\n      callback = options, options = {}, options = options || {};\n    }\n\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      callback(new MongoError('server is closed'));\n      return;\n    }\n\n    const error = basicReadValidations(this, options);\n\n    if (error) {\n      return callback(error);\n    } // Clone the options\n\n\n    options = Object.assign({}, options, {\n      wireProtocolCommand: false\n    }); // Debug log\n\n    if (this.s.logger.isDebug()) {\n      const extractedCommand = extractCommand(cmd);\n      this.s.logger.debug(`executing command [${JSON.stringify({\n        ns,\n        cmd: extractedCommand.shouldRedact ? `${extractedCommand.name} details REDACTED` : cmd,\n        options: debugOptions(DEBUG_FIELDS, options)\n      })}] against ${this.name}`);\n    } // error if collation not supported\n\n\n    if (collationNotSupported(this, cmd)) {\n      callback(new MongoError(`server ${this.name} does not support collation`));\n      return;\n    }\n\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n\n      conn.command(ns, cmd, options, makeOperationHandler(this, conn, cmd, options, cb));\n    }, callback);\n  }\n  /**\n   * Execute a query against the server\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cmd The command document for the query\n   * @param {object} options Optional settings\n   * @param {function} callback\n   */\n\n\n  query(ns, cmd, cursorState, options, callback) {\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      callback(new MongoError('server is closed'));\n      return;\n    }\n\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n\n      conn.query(ns, cmd, cursorState, options, makeOperationHandler(this, conn, cmd, options, cb));\n    }, callback);\n  }\n  /**\n   * Execute a `getMore` against the server\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cursorState State data associated with the cursor calling this method\n   * @param {object} options Optional settings\n   * @param {function} callback\n   */\n\n\n  getMore(ns, cursorState, batchSize, options, callback) {\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      callback(new MongoError('server is closed'));\n      return;\n    }\n\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n\n      conn.getMore(ns, cursorState, batchSize, options, makeOperationHandler(this, conn, null, options, cb));\n    }, callback);\n  }\n  /**\n   * Execute a `killCursors` command against the server\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cursorState State data associated with the cursor calling this method\n   * @param {function} callback\n   */\n\n\n  killCursors(ns, cursorState, callback) {\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      if (typeof callback === 'function') {\n        callback(new MongoError('server is closed'));\n      }\n\n      return;\n    }\n\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n\n      conn.killCursors(ns, cursorState, makeOperationHandler(this, conn, null, undefined, cb));\n    }, callback);\n  }\n  /**\n   * Insert one or more documents\n   * @method\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {array} ops An array of documents to insert\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\n   * @param {object} [options.writeConcern={}] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n\n\n  insert(ns, ops, options, callback) {\n    executeWriteOperation({\n      server: this,\n      op: 'insert',\n      ns,\n      ops\n    }, options, callback);\n  }\n  /**\n   * Perform one or more update operations\n   * @method\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {array} ops An array of updates\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\n   * @param {object} [options.writeConcern={}] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n\n\n  update(ns, ops, options, callback) {\n    executeWriteOperation({\n      server: this,\n      op: 'update',\n      ns,\n      ops\n    }, options, callback);\n  }\n  /**\n   * Perform one or more remove operations\n   * @method\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {array} ops An array of removes\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\n   * @param {object} [options.writeConcern={}] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n\n\n  remove(ns, ops, options, callback) {\n    executeWriteOperation({\n      server: this,\n      op: 'remove',\n      ns,\n      ops\n    }, options, callback);\n  }\n\n}\n\nObject.defineProperty(Server.prototype, 'clusterTime', {\n  get: function () {\n    return this.s.topology.clusterTime;\n  },\n  set: function (clusterTime) {\n    this.s.topology.clusterTime = clusterTime;\n  }\n});\n\nfunction supportsRetryableWrites(server) {\n  return server.description.maxWireVersion >= 6 && server.description.logicalSessionTimeoutMinutes && server.description.type !== ServerType.Standalone;\n}\n\nfunction calculateRoundTripTime(oldRtt, duration) {\n  if (oldRtt === -1) {\n    return duration;\n  }\n\n  const alpha = 0.2;\n  return alpha * duration + (1 - alpha) * oldRtt;\n}\n\nfunction basicReadValidations(server, options) {\n  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {\n    return new MongoError('readPreference must be an instance of ReadPreference');\n  }\n}\n\nfunction executeWriteOperation(args, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // TODO: once we drop Node 4, use destructuring either here or in arguments.\n\n  const server = args.server;\n  const op = args.op;\n  const ns = args.ns;\n  const ops = Array.isArray(args.ops) ? args.ops : [args.ops];\n\n  if (server.s.state === STATE_CLOSING || server.s.state === STATE_CLOSED) {\n    callback(new MongoError('server is closed'));\n    return;\n  }\n\n  if (collationNotSupported(server, options)) {\n    callback(new MongoError(`server ${server.name} does not support collation`));\n    return;\n  }\n\n  const unacknowledgedWrite = options.writeConcern && options.writeConcern.w === 0;\n\n  if (unacknowledgedWrite || maxWireVersion(server) < 5) {\n    if ((op === 'update' || op === 'remove') && ops.find(o => o.hint)) {\n      callback(new MongoError(`servers < 3.4 do not support hint on ${op}`));\n      return;\n    }\n  }\n\n  server.s.pool.withConnection((err, conn, cb) => {\n    if (err) {\n      markServerUnknown(server, err);\n      return cb(err);\n    }\n\n    conn[op](ns, ops, options, makeOperationHandler(server, conn, ops, options, cb));\n  }, callback);\n}\n\nfunction markServerUnknown(server, error) {\n  if (error instanceof MongoNetworkError && !(error instanceof MongoNetworkTimeoutError)) {\n    server[kMonitor].reset();\n  }\n\n  server.emit('descriptionReceived', new ServerDescription(server.description.address, null, {\n    error,\n    topologyVersion: error && error.topologyVersion ? error.topologyVersion : server.description.topologyVersion\n  }));\n}\n\nfunction connectionIsStale(pool, connection) {\n  return connection.generation !== pool.generation;\n}\n\nfunction shouldHandleStateChangeError(server, err) {\n  const etv = err.topologyVersion;\n  const stv = server.description.topologyVersion;\n  return compareTopologyVersion(stv, etv) < 0;\n}\n\nfunction inActiveTransaction(session, cmd) {\n  return session && session.inTransaction() && !isTransactionCommand(cmd);\n}\n\nfunction makeOperationHandler(server, connection, cmd, options, callback) {\n  const session = options && options.session;\n  return function handleOperationResult(err, result) {\n    if (err && !connectionIsStale(server.s.pool, connection)) {\n      if (err instanceof MongoNetworkError) {\n        if (session && !session.hasEnded) {\n          session.serverSession.isDirty = true;\n        }\n\n        if (supportsRetryableWrites(server) && !inActiveTransaction(session, cmd)) {\n          err.addErrorLabel('RetryableWriteError');\n        }\n\n        if (!(err instanceof MongoNetworkTimeoutError) || isNetworkErrorBeforeHandshake(err)) {\n          markServerUnknown(server, err);\n          server.s.pool.clear();\n        }\n      } else {\n        // if pre-4.4 server, then add error label if its a retryable write error\n        if (maxWireVersion(server) < 9 && isRetryableWriteError(err) && !inActiveTransaction(session, cmd)) {\n          err.addErrorLabel('RetryableWriteError');\n        }\n\n        if (isSDAMUnrecoverableError(err)) {\n          if (shouldHandleStateChangeError(server, err)) {\n            if (maxWireVersion(server) <= 7 || isNodeShuttingDownError(err)) {\n              server.s.pool.clear();\n            }\n\n            markServerUnknown(server, err);\n            process.nextTick(() => server.requestCheck());\n          }\n        }\n      }\n    }\n\n    callback(err, result);\n  };\n}\n\nmodule.exports = {\n  Server\n};","map":{"version":3,"sources":["C:/Users/david/Documents/United Plastics/Maintenance/machines/node_modules/mongodb/lib/core/sdam/server.js"],"names":["EventEmitter","require","ConnectionPool","CMAP_EVENT_NAMES","MongoError","relayEvents","BSON","retrieveBSON","Logger","ServerDescription","compareTopologyVersion","ReadPreference","Monitor","MongoNetworkError","MongoNetworkTimeoutError","collationNotSupported","debugOptions","isSDAMUnrecoverableError","isRetryableWriteError","isNodeShuttingDownError","isNetworkErrorBeforeHandshake","maxWireVersion","makeStateMachine","extractCommand","common","ServerType","isTransactionCommand","DEBUG_FIELDS","STATE_CLOSING","STATE_CLOSED","STATE_CONNECTING","STATE_CONNECTED","stateTransition","kMonitor","Symbol","Server","constructor","description","options","topology","s","logger","bson","Binary","Code","DBRef","Decimal128","Double","Int32","Long","Map","MaxKey","MinKey","ObjectId","BSONRegExp","Timestamp","state","credentials","poolOptions","Object","assign","host","port","pool","concat","on","clusterTime","clear","error","markServerUnknown","event","emit","address","reply","roundTripTime","calculateRoundTripTime","duration","supportsRetryableWrites","name","autoEncrypter","connect","destroy","callback","force","close","err","requestCheck","command","ns","cmd","basicReadValidations","wireProtocolCommand","isDebug","extractedCommand","debug","JSON","stringify","shouldRedact","withConnection","conn","cb","makeOperationHandler","query","cursorState","getMore","batchSize","killCursors","undefined","insert","ops","executeWriteOperation","server","op","update","remove","defineProperty","prototype","get","set","logicalSessionTimeoutMinutes","type","Standalone","oldRtt","alpha","readPreference","args","Array","isArray","unacknowledgedWrite","writeConcern","w","find","o","hint","reset","topologyVersion","connectionIsStale","connection","generation","shouldHandleStateChangeError","etv","stv","inActiveTransaction","session","inTransaction","handleOperationResult","result","hasEnded","serverSession","isDirty","addErrorLabel","process","nextTick","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst EventEmitter = require('events');\nconst ConnectionPool = require('../../cmap/connection_pool').ConnectionPool;\nconst CMAP_EVENT_NAMES = require('../../cmap/events').CMAP_EVENT_NAMES;\nconst MongoError = require('../error').MongoError;\nconst relayEvents = require('../utils').relayEvents;\nconst BSON = require('../connection/utils').retrieveBSON();\nconst Logger = require('../connection/logger');\nconst ServerDescription = require('./server_description').ServerDescription;\nconst compareTopologyVersion = require('./server_description').compareTopologyVersion;\nconst ReadPreference = require('../topologies/read_preference');\nconst Monitor = require('./monitor').Monitor;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst MongoNetworkTimeoutError = require('../error').MongoNetworkTimeoutError;\nconst collationNotSupported = require('../utils').collationNotSupported;\nconst debugOptions = require('../connection/utils').debugOptions;\nconst isSDAMUnrecoverableError = require('../error').isSDAMUnrecoverableError;\nconst isRetryableWriteError = require('../error').isRetryableWriteError;\nconst isNodeShuttingDownError = require('../error').isNodeShuttingDownError;\nconst isNetworkErrorBeforeHandshake = require('../error').isNetworkErrorBeforeHandshake;\nconst maxWireVersion = require('../utils').maxWireVersion;\nconst makeStateMachine = require('../utils').makeStateMachine;\nconst extractCommand = require('../../command_utils').extractCommand;\nconst common = require('./common');\nconst ServerType = common.ServerType;\nconst isTransactionCommand = require('../transactions').isTransactionCommand;\n\n// Used for filtering out fields for logging\nconst DEBUG_FIELDS = [\n  'reconnect',\n  'reconnectTries',\n  'reconnectInterval',\n  'emitError',\n  'cursorFactory',\n  'host',\n  'port',\n  'size',\n  'keepAlive',\n  'keepAliveInitialDelay',\n  'noDelay',\n  'connectionTimeout',\n  'checkServerIdentity',\n  'socketTimeout',\n  'ssl',\n  'ca',\n  'crl',\n  'cert',\n  'key',\n  'rejectUnauthorized',\n  'promoteLongs',\n  'promoteValues',\n  'promoteBuffers',\n  'bsonRegExp',\n  'servername'\n];\n\nconst STATE_CLOSING = common.STATE_CLOSING;\nconst STATE_CLOSED = common.STATE_CLOSED;\nconst STATE_CONNECTING = common.STATE_CONNECTING;\nconst STATE_CONNECTED = common.STATE_CONNECTED;\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],\n  [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],\n  [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]\n});\n\nconst kMonitor = Symbol('monitor');\n\n/**\n *\n * @fires Server#serverHeartbeatStarted\n * @fires Server#serverHeartbeatSucceeded\n * @fires Server#serverHeartbeatFailed\n */\nclass Server extends EventEmitter {\n  /**\n   * Create a server\n   *\n   * @param {ServerDescription} description\n   * @param {Object} options\n   */\n  constructor(description, options, topology) {\n    super();\n\n    this.s = {\n      // the server description\n      description,\n      // a saved copy of the incoming options\n      options,\n      // the server logger\n      logger: Logger('Server', options),\n      // the bson parser\n      bson:\n        options.bson ||\n        new BSON([\n          BSON.Binary,\n          BSON.Code,\n          BSON.DBRef,\n          BSON.Decimal128,\n          BSON.Double,\n          BSON.Int32,\n          BSON.Long,\n          BSON.Map,\n          BSON.MaxKey,\n          BSON.MinKey,\n          BSON.ObjectId,\n          BSON.BSONRegExp,\n          BSON.Symbol,\n          BSON.Timestamp\n        ]),\n      // the server state\n      state: STATE_CLOSED,\n      credentials: options.credentials,\n      topology\n    };\n\n    // create the connection pool\n    // NOTE: this used to happen in `connect`, we supported overriding pool options there\n    const poolOptions = Object.assign(\n      { host: this.description.host, port: this.description.port, bson: this.s.bson },\n      options\n    );\n\n    this.s.pool = new ConnectionPool(poolOptions);\n    relayEvents(\n      this.s.pool,\n      this,\n      ['commandStarted', 'commandSucceeded', 'commandFailed'].concat(CMAP_EVENT_NAMES)\n    );\n\n    this.s.pool.on('clusterTimeReceived', clusterTime => {\n      this.clusterTime = clusterTime;\n    });\n\n    // create the monitor\n    this[kMonitor] = new Monitor(this, this.s.options);\n    relayEvents(this[kMonitor], this, [\n      'serverHeartbeatStarted',\n      'serverHeartbeatSucceeded',\n      'serverHeartbeatFailed',\n\n      // legacy events\n      'monitoring'\n    ]);\n\n    this[kMonitor].on('resetConnectionPool', () => {\n      this.s.pool.clear();\n    });\n\n    this[kMonitor].on('resetServer', error => markServerUnknown(this, error));\n    this[kMonitor].on('serverHeartbeatSucceeded', event => {\n      this.emit(\n        'descriptionReceived',\n        new ServerDescription(this.description.address, event.reply, {\n          roundTripTime: calculateRoundTripTime(this.description.roundTripTime, event.duration)\n        })\n      );\n\n      if (this.s.state === STATE_CONNECTING) {\n        stateTransition(this, STATE_CONNECTED);\n        this.emit('connect', this);\n      }\n    });\n  }\n\n  get description() {\n    return this.s.description;\n  }\n\n  get supportsRetryableWrites() {\n    return supportsRetryableWrites(this);\n  }\n\n  get name() {\n    return this.s.description.address;\n  }\n\n  get autoEncrypter() {\n    if (this.s.options && this.s.options.autoEncrypter) {\n      return this.s.options.autoEncrypter;\n    }\n    return null;\n  }\n\n  /**\n   * Initiate server connect\n   */\n  connect() {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    }\n\n    stateTransition(this, STATE_CONNECTING);\n    this[kMonitor].connect();\n  }\n\n  /**\n   * Destroy the server connection\n   *\n   * @param {object} [options] Optional settings\n   * @param {Boolean} [options.force=false] Force destroy the pool\n   */\n  destroy(options, callback) {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = Object.assign({}, { force: false }, options);\n\n    if (this.s.state === STATE_CLOSED) {\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n\n    this[kMonitor].close();\n    this.s.pool.close(options, err => {\n      stateTransition(this, STATE_CLOSED);\n      this.emit('closed');\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n    });\n  }\n\n  /**\n   * Immediately schedule monitoring of this server. If there already an attempt being made\n   * this will be a no-op.\n   */\n  requestCheck() {\n    this[kMonitor].requestCheck();\n  }\n\n  /**\n   * Execute a command\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cmd The command hash\n   * @param {object} [options] Optional settings\n   * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.checkKeys=false] Specify if the bson parser should validate keys.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {Boolean} [options.fullResult=false] Return the full envelope instead of just the result document.\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n  command(ns, cmd, options, callback) {\n    if (typeof options === 'function') {\n      (callback = options), (options = {}), (options = options || {});\n    }\n\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      callback(new MongoError('server is closed'));\n      return;\n    }\n\n    const error = basicReadValidations(this, options);\n    if (error) {\n      return callback(error);\n    }\n\n    // Clone the options\n    options = Object.assign({}, options, { wireProtocolCommand: false });\n\n    // Debug log\n    if (this.s.logger.isDebug()) {\n      const extractedCommand = extractCommand(cmd);\n      this.s.logger.debug(\n        `executing command [${JSON.stringify({\n          ns,\n          cmd: extractedCommand.shouldRedact ? `${extractedCommand.name} details REDACTED` : cmd,\n          options: debugOptions(DEBUG_FIELDS, options)\n        })}] against ${this.name}`\n      );\n    }\n\n    // error if collation not supported\n    if (collationNotSupported(this, cmd)) {\n      callback(new MongoError(`server ${this.name} does not support collation`));\n      return;\n    }\n\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n\n      conn.command(ns, cmd, options, makeOperationHandler(this, conn, cmd, options, cb));\n    }, callback);\n  }\n\n  /**\n   * Execute a query against the server\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cmd The command document for the query\n   * @param {object} options Optional settings\n   * @param {function} callback\n   */\n  query(ns, cmd, cursorState, options, callback) {\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      callback(new MongoError('server is closed'));\n      return;\n    }\n\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n\n      conn.query(ns, cmd, cursorState, options, makeOperationHandler(this, conn, cmd, options, cb));\n    }, callback);\n  }\n\n  /**\n   * Execute a `getMore` against the server\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cursorState State data associated with the cursor calling this method\n   * @param {object} options Optional settings\n   * @param {function} callback\n   */\n  getMore(ns, cursorState, batchSize, options, callback) {\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      callback(new MongoError('server is closed'));\n      return;\n    }\n\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n\n      conn.getMore(\n        ns,\n        cursorState,\n        batchSize,\n        options,\n        makeOperationHandler(this, conn, null, options, cb)\n      );\n    }, callback);\n  }\n\n  /**\n   * Execute a `killCursors` command against the server\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cursorState State data associated with the cursor calling this method\n   * @param {function} callback\n   */\n  killCursors(ns, cursorState, callback) {\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      if (typeof callback === 'function') {\n        callback(new MongoError('server is closed'));\n      }\n\n      return;\n    }\n\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n\n      conn.killCursors(ns, cursorState, makeOperationHandler(this, conn, null, undefined, cb));\n    }, callback);\n  }\n\n  /**\n   * Insert one or more documents\n   * @method\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {array} ops An array of documents to insert\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\n   * @param {object} [options.writeConcern={}] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n  insert(ns, ops, options, callback) {\n    executeWriteOperation({ server: this, op: 'insert', ns, ops }, options, callback);\n  }\n\n  /**\n   * Perform one or more update operations\n   * @method\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {array} ops An array of updates\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\n   * @param {object} [options.writeConcern={}] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n  update(ns, ops, options, callback) {\n    executeWriteOperation({ server: this, op: 'update', ns, ops }, options, callback);\n  }\n\n  /**\n   * Perform one or more remove operations\n   * @method\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {array} ops An array of removes\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\n   * @param {object} [options.writeConcern={}] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n  remove(ns, ops, options, callback) {\n    executeWriteOperation({ server: this, op: 'remove', ns, ops }, options, callback);\n  }\n}\n\nObject.defineProperty(Server.prototype, 'clusterTime', {\n  get: function() {\n    return this.s.topology.clusterTime;\n  },\n  set: function(clusterTime) {\n    this.s.topology.clusterTime = clusterTime;\n  }\n});\n\nfunction supportsRetryableWrites(server) {\n  return (\n    server.description.maxWireVersion >= 6 &&\n    server.description.logicalSessionTimeoutMinutes &&\n    server.description.type !== ServerType.Standalone\n  );\n}\n\nfunction calculateRoundTripTime(oldRtt, duration) {\n  if (oldRtt === -1) {\n    return duration;\n  }\n\n  const alpha = 0.2;\n  return alpha * duration + (1 - alpha) * oldRtt;\n}\n\nfunction basicReadValidations(server, options) {\n  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {\n    return new MongoError('readPreference must be an instance of ReadPreference');\n  }\n}\n\nfunction executeWriteOperation(args, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  // TODO: once we drop Node 4, use destructuring either here or in arguments.\n  const server = args.server;\n  const op = args.op;\n  const ns = args.ns;\n  const ops = Array.isArray(args.ops) ? args.ops : [args.ops];\n\n  if (server.s.state === STATE_CLOSING || server.s.state === STATE_CLOSED) {\n    callback(new MongoError('server is closed'));\n    return;\n  }\n\n  if (collationNotSupported(server, options)) {\n    callback(new MongoError(`server ${server.name} does not support collation`));\n    return;\n  }\n  const unacknowledgedWrite = options.writeConcern && options.writeConcern.w === 0;\n  if (unacknowledgedWrite || maxWireVersion(server) < 5) {\n    if ((op === 'update' || op === 'remove') && ops.find(o => o.hint)) {\n      callback(new MongoError(`servers < 3.4 do not support hint on ${op}`));\n      return;\n    }\n  }\n\n  server.s.pool.withConnection((err, conn, cb) => {\n    if (err) {\n      markServerUnknown(server, err);\n      return cb(err);\n    }\n\n    conn[op](ns, ops, options, makeOperationHandler(server, conn, ops, options, cb));\n  }, callback);\n}\n\nfunction markServerUnknown(server, error) {\n  if (error instanceof MongoNetworkError && !(error instanceof MongoNetworkTimeoutError)) {\n    server[kMonitor].reset();\n  }\n\n  server.emit(\n    'descriptionReceived',\n    new ServerDescription(server.description.address, null, {\n      error,\n      topologyVersion:\n        error && error.topologyVersion ? error.topologyVersion : server.description.topologyVersion\n    })\n  );\n}\n\nfunction connectionIsStale(pool, connection) {\n  return connection.generation !== pool.generation;\n}\n\nfunction shouldHandleStateChangeError(server, err) {\n  const etv = err.topologyVersion;\n  const stv = server.description.topologyVersion;\n\n  return compareTopologyVersion(stv, etv) < 0;\n}\n\nfunction inActiveTransaction(session, cmd) {\n  return session && session.inTransaction() && !isTransactionCommand(cmd);\n}\n\nfunction makeOperationHandler(server, connection, cmd, options, callback) {\n  const session = options && options.session;\n\n  return function handleOperationResult(err, result) {\n    if (err && !connectionIsStale(server.s.pool, connection)) {\n      if (err instanceof MongoNetworkError) {\n        if (session && !session.hasEnded) {\n          session.serverSession.isDirty = true;\n        }\n\n        if (supportsRetryableWrites(server) && !inActiveTransaction(session, cmd)) {\n          err.addErrorLabel('RetryableWriteError');\n        }\n\n        if (!(err instanceof MongoNetworkTimeoutError) || isNetworkErrorBeforeHandshake(err)) {\n          markServerUnknown(server, err);\n          server.s.pool.clear();\n        }\n      } else {\n        // if pre-4.4 server, then add error label if its a retryable write error\n        if (\n          maxWireVersion(server) < 9 &&\n          isRetryableWriteError(err) &&\n          !inActiveTransaction(session, cmd)\n        ) {\n          err.addErrorLabel('RetryableWriteError');\n        }\n\n        if (isSDAMUnrecoverableError(err)) {\n          if (shouldHandleStateChangeError(server, err)) {\n            if (maxWireVersion(server) <= 7 || isNodeShuttingDownError(err)) {\n              server.s.pool.clear();\n            }\n\n            markServerUnknown(server, err);\n            process.nextTick(() => server.requestCheck());\n          }\n        }\n      }\n    }\n\n    callback(err, result);\n  };\n}\n\nmodule.exports = {\n  Server\n};\n"]},"metadata":{},"sourceType":"script"}